<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Pico.CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css" />
    <!-- Stylesheet -->
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <title>Jose Arana Blog</title>
  </head>
  <body>
    <header class="hero">
      <div class="container">
        <hgroup>
          <h1>Apprenticeship Blog</h1>
          <p class="titledark"><strong>by Jose Arana</strong></p>
        </hgroup>
      </div>
    </header>
    <main class="container">
      <article>
        <details open>
          <summary>
            <h3>Week 04: Breakable Toy</h3>
            <p>
              <strong
                >(Apr 25 - May 9) Individual console line application</strong
              >
            </p>
          </summary>
          <hr />
          <p>
            After delivering the team coding assignments we were given a new
            task, we now had to recreate <em>Ledger</em> a CLI application for
            accounting. The real <em>Ledger</em> is a very powerful and complete
            tool, however, so in order to keep things reasonable we only had to
            implement three commands and three flags. The commands given were
            <strong>register, balance, and print.</strong> while the flags to
            implement were
            <strong>--sort, --file, and --price-db.</strong>
          </p>
          <h4>Command: register</h4>
          <p>
            The command <strong>register</strong> outputs a list of all the
            transactions, formatted like a double entry accounting book. Going
            left to right we have a date for the transaction, the accounts
            involved, the value traded in the transaction and finally a running
            balance, which is independent for each currency or symbol used.
          </p>
          <img src="./pictures/register.png" alt="output of register command">
          <p>
            In order to output the data in this format the code must read
            through every filename specified in "index.ledger". Then parse every
            entry contained in the files and append them to a dictionary. The
            dictionary is formatted like a JSON so that it can be read by the
            python library <em>Pandas</em> and turned into a dataframe. This was
            done to facilitate the task of formatting the output, filtering and
            sorting.
          </p>
          <img src="./pictures/entrymaker.png" alt="code used to parse through files">
          <p>
            By using the optional flag <strong>--account</strong> the table can
            be narrowed down to only the transactions where the account
            specified was involved. The choice was made to implement this
            functionality as a flag instead of a positional attribute of
            <strong>register</strong> because that was simpler to implement
            using the argparse library.
          </p>
          <img src="./pictures/register_a.png" alt="output of register command when using account flag">
          <h4>Command: balance</h4>
          <p>
            The command <strong>balance</strong>
            outputs the total balance of all accounts. Because in the
            <strong>register</strong> command we already have a running balance
            column, we could reuse most of the code for register by moving it to
            its own function. Then we simply use pandas to colapse the running
            balance column, so we only keep the last value on it.
          </p>
          <img src="./pictures/balance_brain.png" alt="code used to create the balance output">
          <p>
            Like <strong>register</strong> this command could also make use of
            the account flag to only show the total of the transactions
            involving that account.
          </p>
          <img src="./pictures/balance_a.png" alt="output of balance command">
          <h4>Command: print</h4>
          <p>
            The command <strong>print</strong> was to me the simplest one, as it
            only needs to read through the ledger data and prints it out in an
            homogenized format. I reused most of the code from the previous two
            commands. As with both previous commands, <strong>print</strong> can make use
            of the account flag to select which accounts to actually show.
          </p>
          <img src="./pictures/print.png" alt="output of print command">
          <h4>Flag: --prices-db</h4>
          <p>
            The <strong>--prices-db</strong> flag does two things: It tells ledger that you want the output to show in a single currency, and in the specified file it lets you define what currency to output and what the exchange rate will be. Out of the optional flags this was the most involved one, so much that the code was split off for the register command, there is one version for its normal functioning and another for when this command is called.
          </p>
          <img src="./pictures/prices_code.png" alt="code used to change units and convert according to exchange rate">
          <p>
            Compare the output when the function is not called and when it is:
          </p>
          <img src="./pictures/prices_bal.png" alt="output of balance when using prices-database command">
          <img src="./pictures/prices_reg.png" alt="output of register when using prices-database command">
          <h4>Flag: --file</h4>
          <p>
            The <strong>--file</strong> flag specifies what file should be used as the index, the index.ledger text file contains the filenames of all entries for ledger. Being that ledger is originally an accounting tool, this could be considered a useful functionality to change between clients, for example. In the case of our implementation though we always default back to "index.ledger" when executing the code again. The implementation of this flag was very simple, we converted all references to index.ledger to variables and used an if statement to check if the flag was being passed as an argument.
          </p>
          <img src="./pictures/file_code.png" alt="if statement used to check if file was passed as an argument">
          <h4>Flag: --sort</h4>
          <p>
            The <strong>--sort</strong> flag is used to sort the output, the real <em>Ledger</em> can take any EXPR as an argument, in our case we have only included "date" and variations as valid arguments.
          </p>
          <img src="./pictures/register_sorted.png" alt="register output sorted by date">
          <h4>Conclusion</h4>
          <p>
            Ledger is one of the most complex programs that I've built on my own, if not the most complex. There was a moment when I felt like the complexity was too much to handle by myself. But as I powered through I found it really rewarding and by splitting my functions over many files I found it easier to keep track of everything.
          </p>
          <p>
            I made many mistakes while building Ledger, I should've read more carefully what each function was supposed to do, as I found myself having to go back to tweak the code many times. However I don't regret starting to code without having the full picture, there was nothing i wrote that didn't come useful later, and I hold the belief that getting started is usually the most difficult part of any project.
          </p>
          <hr />
          <small>Uploaded on May 9, 2023</small>
        </details>
      </article>
      <article>
        <details>
          <summary>
            <h3>Week 03: Come Together</h3>
            <p>
              <strong
                >(Apr 14 - Apr 24) Individual and team coding
                assignments</strong
              >
            </p>
          </summary>
          <hr />
          <p>
            The first couple of weeks in Encora were spent getting to know the
            company and completing the prerequisite courses on matters of
            diversity, communication and security. I can’t speak for everyone,
            but I know at least I was excited to finally be back to coding after
            what felt like a long break. The activities for the week seemed
            simple enough: An individual problem and five team problems, but we
            also had to balance building the foundations of our personal blog,
            making the technical logs and unexpectedly, organizing newbie
            Friday. This was quite the change from the leisurely pace of the
            first couple of weeks.
          </p>
          <p>
            I had a schedule carefully planned for the week, I’d solve the
            individual challenge on the first couple of days, work with the team
            on the team challenges through the next five days and use the
            remaining time to build the blog, if I had enough time left over, I
            would build the blog using Svelte as an SPA, otherwise I would use
            pico.CSS to whip up something fast. You’re most likely looking at
            that “something fast” right now.
          </p>
          <p>
            It was a great plan, but in the words of Mike Tyson: Everyone has a
            plan until they are punched in the face. In my case the punch was
            called “Double or One Thing”.
          </p>
          <h4>Double or One Thing</h4>
          <p>
            We could pick one out of three options for our individual problem.
            Double or One Thing seemed the obvious choice to me, if only because
            I could understand what the problem was even asking for. The
            descriptions for the Google Code Jam problems might as well be
            written in a different language and deciphering them proved to be a
            valuable skill on its own. To quote the problem intro:
          </p>
          <blockquote>
            You are given a string of uppercase English letters. You can
            highlight any number of the letters. Then, a new string is produced
            by processing the letters from left to right: non-highlighted
            letters are appended once to the new string, while highlighted
            letters are appended twice. There are multiple strings that can be
            obtained as a result of this process, depending on the highlighting
            choices. Among all of those strings, output the one that appears
            first in alphabetical order.
          </blockquote>
          <p>
            To tackle this problem, we are given two options. The first option
            was a brute force solution that writes every possible combination of
            single and double letters to a list, sorts the list, and picks the
            first element. This was simple enough to implement and after a
            couple of hours remembering how to code and another couple figuring
            out how Google Code Jam checks each answer, we had a working
            solution.
          </p>
          <p>
            Of course, this wouldn’t cut it for all the test sets. The analysis
            page says as much, this algorithm runs out of time once the words
            get large enough. As if that wasn't bad enough, the optimal solution
            has little to do with the brute force solution.
          </p>
          <p>
            It took another six hours or so to write the second algorithm, most
            of that time was spent writing the wrong algorithm, I had to
            practically start over a couple of times, but we finally had a
            solution that should be capable of solving the samples as well as
            both tests. But somehow, the improved solution was worse than the
            original. Like a person who hasn’t worked out in a while, my brain
            had completely depleted its reserve of abstract thoughts. I decided
            to let it rest and come back to the problem after some days.
          </p>
          <h4>Punched Cards</h4>
          <p>
            On Monday, April 17 we got together as a team to decide how we would
            split the work for the week, we decided on an intentionally
            inefficient strategy: We would split the eight-person team into
            couples, for each problem each team was assigned a language out of
            the four we needed to complete the challenge, we would rotate the
            language for each problem. The goal was that everybody had a chance
            to get familiar with Dart and Kotlin, the languages no one had any
            prior experience with.
          </p>
          <p>
            In retrospective that made things harder for everyone. Every problem
            was essentially “solved” in Python and then rewritten to the other
            languages. And once we realized that Kotlin, for example, had a
            Java-like syntax it seemed obvious that those with prior experience
            with Java would be best suited to port the solutions to the
            language. Had we realized these things earlier on we might have
            saved ourselves some trouble, or we might have ended up doing the
            same since it was the most egalitarian choice. Either way, it was an
            important lesson.
          </p>
          <p>
            I was partnered up with Karen, and for the first problem she had
            already written a solution during the weekend, because that file was
            already on hand it ended up being used to test the GitHub repo that
            Edgar made to store all our solutions. For many of us this was our
            first time uploading to someone else’s repository, so that took a
            bit of trial and error to figure out.
          </p>
          <p>
            Punched Cards ended up giving us no problems, the algorithm was
            simple enough: Write X lines Y times. With just a bit of extra code
            to replace the beginning “cell” of the table with dots.
          </p>
          <h4>3D Printing</h4>
          <p>
            For Tuesday we had to work on the second problem, 3D Printing. It
            was trickier than Punched Cards but not particularly complicated:
          </p>
          <blockquote>
            You are part of the executive committee of the Database Design Day
            festivities. You are in charge of promotions and want to print three
            D's to create a logo of the contest. You can choose any color you
            want to print them, but all three have to be printed in the same
            color.
          </blockquote>
          <p>
            We had talked about how to solve it during the meeting on Monday and
            had devised a greedy solution: On each loop take one unit of ink out
            of each color until we either run out of ink or we get to the
            desired units of ink.
          </p>
          <p>
            Because Karen had written the solution to Punched Cards, I decided
            to start working early on 3D Printing. Our assigned language for
            this problem was typescript, something neither of us was familiar
            with. I managed to build the logic for the printers through the day,
            it was about the same principle as the discussed solution but taking
            all the ink possible up front and then reducing it until getting to
            exactly 10^6.
          </p>
          <p>
            The task to handle the input and output of the problem fell on
            Karen, and that proved to be a challenge on its own since TS alone
            can't handle input, it required a particular library and a fair bit
            of trial and error to figure out how to get it to run on GCJ.
          </p>
          <h4>D1000000</h4>
          <p>
            The third problem turned out to be surprisingly simple, "Longest
            Straight" type of problems are a staple so I had seen some before.
            To solve it you start counting at 1 for the first dice and add +1
            for each dice if the sum is less than the sides of the current dice.
            The resulting number once you have processed all the dice is the
            longest straight that can be built using the dice provided by the
            input.
          </p>
          <p>
            We solved the logic for the problem using Python and then I ported
            it to Dart. The Google Code Jam compiler has issues with the latest
            version of Dart, something we confirmed as every team had trouble
            getting it to run their code. For this problem and this solution, it
            was seemingly running slower than the same algorithm coded in other
            languages, and it timed out during the last test set. However, we
            were able to confirm that it was giving the right answers using the
            provided test data running locally or on replit. With the two
            hardest problems still to come we had to move to the next one on the
            list.
          </p>
          <h4>Chain Reactions</h4>
          <p>
            Chain Reactions was truly a team effort. Bryan had started to work
            on it early so he gave us a high-level explanation of the logic
            necessary to solve the problem. This was later implemented by Adrian
            and Salma using a special node tree class. To cut down on the code I
            rewrote that solution to use a dictionary as the node tree instead,
            so we didn’t need to translate as many lines to Kotlin.
          </p>
          <p>
            The algorithm is a postorder traversal, on each node the algorithm
            checks the values of each child node, if the lowest value is higher
            than the value of the current node, replace the value of the current
            node with the lowest value, any nodes that are left over are
            appended to a list and summed at the end.
          </p>
          <h4>Twisty Little Passages</h4>
          <p>
            Twisty Little Passages was the last and most complex problem. In the
            end we had to settle on a brute force solution: Visit as many rooms
            as possible, make an average of the passages in each room, multiply
            that number by the total number of rooms and divide the resulting
            number by two, as each passage connects two rooms.
          </p>
          <h4>Final Thoughts</h4>
          <p>
            After the team problems were finished it was time to go back to
            Double or One Thing. It turned out that the reason why it was
            returning the wrong answer was because I hadn’t accounted for words
            that have duplicated letters before going into the algorithm. It was
            a quick fix, only needing three more lines of code and leaving
            everything else unchanged.
          </p>
          <p>
            I found the week to be very productive, I brushed up my Python
            skills, learned more about Typescript and dipped my toes in Dart and
            Kotlin. I’m looking forward to wrapping up this week and starting
            the next module.
          </p>
          <hr />
          <small>Uploaded on April 24, 2023</small>
        </details>
      </article>
    </main>
  </body>
</html>
